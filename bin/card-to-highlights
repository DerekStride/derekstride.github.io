#!/usr/bin/env ruby

require "bundler/setup"
require "optparse"
require "logger"
require "json"
require "debug"
require "sqlite3"
require "toml-rb"

$stdout.sync = $stderr.sync = true
def level = ENV.fetch("LOG_LEVEL", Logger::WARN)
def progname = File.basename($0)
def logger = @logger ||= Logger.new($stderr, level:, progname:)
def options = @options ||= {}
def enoent!(pathname) = logger.error("File not found: #{pathname}") && exit(Errno::ENOENT::Errno)

DEFAULT_AUTHOR = "Derek Stride"
DEFAULT_DB_PATH = "flashcards/cards/hashcards.db"

OptionParser.new do |o|
  o.accept(Pathname) { Pathname.new(_1) }

  o.banner = "usage: ruby #{progname} [options]"
  o.on("-v", "--verbose", "Enable verbose logging") { logger.level -= 1 }
  o.on("-f", "--file=FILE", Pathname, "Path to hashcards JSON file (default: tmp/hashcards.json)") { |file| options[:file] = file.exist? ? file : enoent!(file) }
  o.on("-o", "--output=FILE", Pathname, "Path to output highlights JSON file (default: stdout)") { |file| options[:output] = file }
  o.on("-d", "--db=FILE", Pathname, "Path to hashcards SQLite database (default: #{DEFAULT_DB_PATH})") { |file| options[:db] = file.exist? ? file : enoent!(file) }
end.parse!(ARGV, into: options)

options[:file] ||= Pathname.new("tmp/hashcards.json").then { _1.exist? ? _1 : enoent!(_1) }
options[:db] ||= Pathname.new(DEFAULT_DB_PATH).then { _1.exist? ? _1 : nil }

logger.debug("options=#{options}")

def load_added_at_timestamps(db_path)
  return {} unless db_path&.exist?

  db = SQLite3::Database.new(db_path.to_s)
  results = db.execute("SELECT card_hash, added_at FROM cards")
  results.to_h { |row| [row[0], row[1]] }
rescue SQLite3::Exception => e
  logger.warn("Failed to load timestamps from database: #{e.message}")
  {}
ensure
  db&.close
end

# Parse TOML frontmatter from a markdown file
# Returns hash with keys: author, source_url, image_url, tags
def parse_frontmatter(file_path)
  return {} unless File.exist?(file_path)

  content = File.read(file_path)
  return {} unless content.start_with?("---")

  # Extract frontmatter between first --- and second ---
  parts = content.split("---", 3)
  return {} if parts.length < 3

  toml_content = parts[1].strip
  return {} if toml_content.empty?

  TomlRB.parse(toml_content)
rescue TomlRB::ParseError => e
  logger.warn("Failed to parse frontmatter from #{file_path}: #{e.message}")
  {}
end

# Cache frontmatter by file path
def frontmatter_cache
  @frontmatter_cache ||= {}
end

def get_frontmatter(file_path)
  frontmatter_cache[file_path] ||= parse_frontmatter(file_path)
end

def card_to_highlight(card, timestamps)
  content = card["content"]
  text = if content["cloze"]
    content["cloze"]["text"]
  elsif content["frontBack"]
    "Q: #{content["frontBack"]["front"]}\nA: #{content["frontBack"]["back"]}"
  else
    logger.warn("Unknown card content type: #{content.keys}")
    return nil
  end

  # Get frontmatter from source file
  file_path = card.dig("location", "filePath")
  fm = file_path ? get_frontmatter(file_path) : {}

  # Build note with tags
  note_parts = [".hashcard"]
  if fm["tags"]&.any?
    fm["tags"].each { |tag| note_parts << ".#{tag}" }
  end
  note = note_parts.join("\n")

  hash = card["hash"]
  highlighted_at = timestamps[hash]

  {
    text: text,
    title: card["deckName"],
    author: fm["author"] || DEFAULT_AUTHOR,
    source_type: "hashcards#sync#derek",
    category: "articles",
    note: note,
    source_url: fm["source_url"],
    image_url: fm["image_url"],
    highlighted_at: highlighted_at,
    highlight_url: "hashcards://#{hash}"
  }.compact
end

def main
  hashcards = JSON.parse(options[:file].read)
  logger.info("Loaded #{hashcards["cards"].size} cards from #{options[:file]}")

  timestamps = load_added_at_timestamps(options[:db])
  logger.info("Loaded #{timestamps.size} timestamps from database") if timestamps.any?

  highlights = hashcards["cards"].filter_map { |card| card_to_highlight(card, timestamps) }
  logger.info("Converted #{highlights.size} highlights")
  logger.info("Parsed frontmatter from #{frontmatter_cache.size} files")

  output = JSON.pretty_generate({ highlights: highlights })

  if options[:output]
    options[:output].write(output)
    logger.info("Wrote highlights to #{options[:output]}")
  else
    puts output
  end
end

main
